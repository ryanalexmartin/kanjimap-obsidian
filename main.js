/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZhuyinHighlighterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// ZhuyinHighlighter.ts
var ZhuyinHighlighter = class {
  constructor(app, settings, characterData) {
    this.app = app;
    this.settings = settings;
    this.characterData = characterData;
    this.injectStyles();
  }
  updateSettings(settings) {
    this.settings = settings;
    this.app.workspace.trigger("layout-change");
  }
  processElement(el) {
    this.highlightKanji(el);
  }
  highlightKanji(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      const kanjiRegex = /[\u4e00-\u9faf]/g;
      let match;
      let lastIndex = 0;
      const fragments = [];
      if (!text) {
        return;
      }
      while ((match = kanjiRegex.exec(text)) !== null) {
        if (match.index > lastIndex) {
          fragments.push(document.createTextNode(text.slice(lastIndex, match.index)));
        }
        if (match[0]) {
          const kanji = match[0];
          if (!this.characterData.isLearned(kanji)) {
            const span = document.createElement("span");
            span.className = `kanji-highlight ${this.settings.orientation}`;
            const ruby = document.createElement("ruby");
            const rb = document.createElement("rb");
            rb.textContent = kanji;
            ruby.appendChild(rb);
            const rt = document.createElement("rt");
            rt.textContent = this.characterData.getZhuyin(kanji);
            ruby.appendChild(rt);
            span.appendChild(ruby);
            fragments.push(span);
          } else {
            fragments.push(document.createTextNode(kanji));
          }
        }
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < text.length) {
        fragments.push(document.createTextNode(text.slice(lastIndex)));
      }
      if (fragments.length > 1) {
        const parent = node.parentNode;
        const container = document.createElement("span");
        fragments.forEach((fragment) => container.appendChild(fragment));
        if (node.parentNode) {
          node.parentNode.replaceChild(container, node);
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE && !["SCRIPT", "STYLE", "TEXTAREA", "RUBY", "RT", "RB"].includes(node.nodeName)) {
      Array.from(node.childNodes).forEach((child) => this.highlightKanji(child));
    }
  }
  injectStyles() {
    const style = document.createElement("style");
    style.textContent = `
            .kanji-highlight {
                display: inline-block;
                vertical-align: baseline;
                line-height: normal;
                position: relative;
            }
            .kanji-highlight ruby {
                display: inline-flex;
                vertical-align: baseline;
                line-height: 1;
            }
            .kanji-highlight rb {
                display: inline-block;
                font-size: 1em;
                line-height: inherit;
            }
            .kanji-highlight rt {
                display: inline-block;
                font-size: 0.3em;
                line-height: normal;
                text-align: start;
                color: inherit;
                font-weight: normal;
            }
            .kanji-highlight.vertical-right {
                margin-right: 0.4em;
            }
            .kanji-highlight.vertical-right rt {
                display: flex;
                justify-content: center;
                align-items: center;
                writing-mode: vertical-rl;
                text-orientation: upright;
                position: absolute;
                top: 0;
                right: -1.2em;
                height: 100%;
            }
            .kanji-highlight.horizontal-above rt {
                position: absolute;
                top: -0.6em;
                left: 50%;
                transform: translateX(-50%);
                white-space: nowrap;
            }
            .kanji-highlight.horizontal-below rt {
                position: absolute;
                bottom: -0.9em;
                left: 50%;
                transform: translateX(-50%);
                white-space: nowrap;
            }
        `;
    document.head.appendChild(style);
  }
};

// CharacterData.ts
var CharacterData = class {
  constructor(plugin) {
    this.zhuyinData = /* @__PURE__ */ new Map();
    this.learnedCharacters = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.loadZhuyinData();
    this.loadLearnedCharacters();
  }
  async loadZhuyinData() {
    try {
      const response = await fetch(this.plugin.app.vault.adapter.getResourcePath("characters.json"));
      const data = await response.json();
      data.forEach((entry) => {
        if (entry.meanings && entry.meanings.length > 0) {
          this.zhuyinData.set(entry.word, entry.meanings[0].bopomofo);
        }
      });
      console.log("Zhuyin data loaded successfully");
    } catch (error) {
      console.error("Failed to load Zhuyin data:", error);
    }
  }
  async loadLearnedCharacters() {
    const learned = await this.plugin.loadData();
    if (learned && learned["learned-characters"]) {
      this.learnedCharacters = new Set(learned["learned-characters"]);
    }
  }
  async saveLearnedCharacters() {
    await this.plugin.saveData({
      key: "learned-characters",
      value: Array.from(this.learnedCharacters)
    });
  }
  isLearned(character) {
    return this.learnedCharacters.has(character);
  }
  getZhuyin(character) {
    return this.zhuyinData.get(character) || "";
  }
  async toggleLearned(character) {
    if (this.learnedCharacters.has(character)) {
      this.learnedCharacters.delete(character);
    } else {
      this.learnedCharacters.add(character);
    }
    await this.saveLearnedCharacters();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enabled: true,
  orientation: "horizontal-above"
};
var ZhuyinHighlighterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.characterData = new CharacterData(this);
    this.highlighter = new ZhuyinHighlighter(this.app, this.settings, this.characterData);
    this.addSettingTab(new ZhuyinHighlighterSettingTab(this.app, this));
    this.registerMarkdownPostProcessor((el, ctx) => {
      if (this.settings.enabled) {
        this.highlighter.processElement(el);
      }
    });
    this.addCommand({
      id: "toggle-zhuyin-highlighter",
      name: "Toggle Zhuyin Highlighter",
      callback: () => {
        this.settings.enabled = !this.settings.enabled;
        this.saveSettings();
        this.highlighter.updateSettings(this.settings);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ZhuyinHighlighterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Zhuyin Highlighter Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Zhuyin Highlighter").setDesc("Turn on/off Zhuyin highlighting").addToggle((toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
      this.plugin.settings.enabled = value;
      await this.plugin.saveSettings();
      this.plugin.highlighter.updateSettings(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Ruby Orientation").setDesc("Choose the orientation of the Zhuyin ruby text").addDropdown((dropdown) => dropdown.addOption("vertical-right", "Vertical Right").addOption("horizontal-above", "Horizontal Above").addOption("horizontal-below", "Horizontal Below").setValue(this.plugin.settings.orientation).onChange(async (value) => {
      this.plugin.settings.orientation = value;
      await this.plugin.saveSettings();
      this.plugin.highlighter.updateSettings(this.plugin.settings);
    }));
  }
};
